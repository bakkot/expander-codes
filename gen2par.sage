# this assumes generator matrices are k x n, i.e. encoding is wG
# and parity-check matrices are (n-k) x n, i.e. checking is Px

# Facts:
# 1. Elementary row operations do not change the code generated by a matrix.
#    i.e., the rref of generator matrix generates the same code.
# 2. If a generator matrix is in "standard form" [ I_k | A ], then the parity check check matrix is given by [ -A^T | I_{n-k} ].
#
# 2 can be generalized to non-standard-form generators by forming A from the non-leading columns and then inserting columns of I_{n-k} into A^T at the indices where the non-leading columns in fact occurred.
# (where "leading column" means a column equal to a standard basis vector)

def gen2par(G, F = GF(2)):
	# is also par2gen

	# Assumes G is not deficient, i.e., is of rank equal to its height.
	# If this is not the case, rref it and stip off excess rows.
	R = G.rref() # vs .echelon_form()?

	k = G.nrows()
	n = G.ncols()
	i = 0
	non_leading_columns = []

	ei = vector(F, [0]*i + [1] + [0]*(k-i-1))
	for j in range(n):
		if R.column(j) != ei:
			non_leading_columns.append(j)
		else:
			i += 1
			if i == k:
				for jj in range(j+1, n):
					non_leading_columns.append(jj)
				break
			ei = vector(F, [0]*i + [1] + [0]*(k-i-1))

	At = R.matrix_from_columns(non_leading_columns).transpose()
	P_cols = []

	i = 0
	for j in range(n):
		if i < len(non_leading_columns) and j == non_leading_columns[i]:
			P_cols.append(vector(F, [0]*i + [1] + [0]*(n-k-i-1)))
			i += 1
		else:
			P_cols.append(-At.column(j-i))
	return matrix(P_cols).transpose() # transpose because matrix() takes a list of rows


def print_from_parity(P):
	res = []
	n = P.ncols()
	for i in range(2**n):
		w = bin(i)[2:]
		w = vector(GF(2), [0]*(n-len(w))+list(w))
		if P*w == 0:
			res.append(w)
	for r in sorted(res):
		print(r)

def print_from_generator(G):
	res = []
	k = G.nrows()
	for i in range(2**k):
		w = bin(i)[2:]
		w = vector(GF(2), [0]*(k-len(w))+list(w))
		res.append(w*G)
	for r in sorted(res):
		print(r)



G = MatrixSpace(GF(2), 4, 7)([
[0,1,1,0,0,0,1],
[1,1,1,1,1,1,1],
[1,0,0,0,1,0,1],
[1,1,0,0,0,1,0]
])

G2 = MatrixSpace(GF(2), 2, 3)([
[1, 1, 0],
[0, 0, 1]
])

Had = MatrixSpace(GF(2), 3, 7)([
[0, 0, 0, 1, 1, 1, 1],
[0, 1, 1, 0, 0, 1, 1],
[1, 0, 1, 0, 1, 0, 1]
])

print(gen2par(Had))

Par = MatrixSpace(GF(2), 1, 3)([
[1, 1, 1]
])
#print(vector(GF(2), [0, 1]) * gen2par(Par))

T = MatrixSpace(GF(2), 3, 4)([
[1, 0, 1, 1],
[0, 1, 1, 1],
[1, 1, 0, 0],
])


P = gen2par(G)

print_from_generator(G)
print('')
print_from_parity(P)

