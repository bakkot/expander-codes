
from random import randrange

# from gen2par.sage import gen2par
# ugh
def gen2par(G, F = GF(2)):
  # is also par2gen
  R = G.rref() # vs .echelon_form()?

  k = G.nrows()
  n = G.ncols()
  i = 0
  non_leading_columns = []

  ei = vector(F, [0]*i + [1] + [0]*(k-i-1))
  for j in range(n):
    if R.column(j) != ei:
      non_leading_columns.append(j)
    else:
      i += 1
      if i == k:
        for jj in range(j+1, n):
          non_leading_columns.append(jj)
        break
      ei = vector(F, [0]*i + [1] + [0]*(k-i-1))

  At = R.matrix_from_columns(non_leading_columns).transpose()
  P_cols = []

  i = 0
  for j in range(n):
    if i < len(non_leading_columns) and j == non_leading_columns[i]:
      P_cols.append(vector(F, [0]*i + [1] + [0]*(n-k-i-1)))
      i += 1
    else:
      P_cols.append(-At.column(j-i))
  return matrix(P_cols).transpose() # transpose because matrix() takes a list of rows


class ParityCode:
  def __init__(self, n):
    self.n = n
    self.P = MatrixSpace(GF(2), 1, n)([1]*n)
  def encode(self, mess):
    return mess + [sum(x for x in mess) % 2]
  def is_codeword(self, w):
    return sum(x for x in w) % 2 == 0
  def nearest_codeword(self, w):
    if self.is_codeword(w):
      return w
    flip = randrange(len(w))
    w = w[:]
    w[flip] = 1 - w[flip]
    return w


def to_bits(n, d):
  w = bin(d)[2:]
  return [[0]*(n-len(w)) + list(int(b) for b in w)]

class Hadamard:
  def __init__(self, k):
    self.k = k
    self.d = 2**(k-1)
    self.n = 2**k - 1

    cols = []
    for i in range(1, 2**k):
      cols += to_bits(k, i)
    self.G = matrix(GF(2), cols).transpose()

    self.P = gen2par(self.G)
    print(self.P)

  def encode(self, w):
    t = vector(GF(2), reversed(w)) * self.G
    return t

  def decode(self, w):
    x = []
    for i in range(self.k):
      ones = 0
      for j in range(2**self.k):
        k = j ^^ (2**i)

        # correct for lack of leading-zeros column
        j -= 1
        k -= 1
        if j == -1:
          if k == -1:
            continue
          if w[k] == 1:
            ones += 1
            continue
        if k == -1:
          if w[j] == 1:
            ones += 1
            continue          
        if w[j] + w[k] == 1:
          ones += 1

      x.append(1 if ones >= 2**(self.k - 1) else 0)
    return vector(GF(2), x)

  def nearest_codeword(self, w):
    return self.encode(self.decode(w))

  def is_codeword(self, w):
    return self.P * w == 0





class Expander:
  def __init__(self, G, S):
    # G should be a d-regular bipartite graph on l vertices with second eigenvalue \leq 2*sqrt(d-1).
    #  Its edge-vertex incidence graph, a (2, d)-regular bipartite graph, will be used as the expander.
    #  i.e., the "variables" are the edges of G, and the "constraints" are its vertices.
    # S should be a linear binary code with block length d.
    # We do not verify those properties here.
    # Codewords are bit arrays of length d*l.
    self.G = G
    self.S = S
    self.n = G.size()
    # self.A, self.B = G.bipartition()
    self.edge_map = { e:i for (i, e) in enumerate(G.edges(labels = False)) }

    S_P_height = self.S.P.nrows()
    row_blocks = []
    for v in G.vertices():
      Ev = self.G.edges_incident(v, labels = False)
      x_indices = [self.edge_map[e] for e in Ev]
      row_block = []
      ind = 0
      for i in range(self.n):
        if ind < len(x_indices) and i == x_indices[ind]:
          row_block.append(self.S.P.column(ind))
          ind += 1
        else:
          row_block.append(vector(GF(2), [0]*S_P_height))
      row_blocks.append(matrix(GF(2), row_block))
    # print(row_blocks, len(row_blocks))
    self.P = block_matrix(row_blocks, ring = GF(2), ncols = len(row_blocks), subdivide = False).transpose()
    # This is an extremely silly way of mashing things together, you say? Yes it is. But it does work.
    self.P = self.P.rref()
    excess = []
    for i in range(self.P.nrows() - 1, -1, -1):
      if self.P.row(i) == 0:
        excess.append(i)
      else:
        break

    self.P = self.P.delete_rows(excess)
    self.Gen = gen2par(self.P)

    w = vector(GF(2), [1]*self.Gen.nrows())
    print(self.encode(w))
    print(self.is_codeword(self.encode(w)))

    t = self.encode(w)
    print('tttt')
    print(t)
    tt = t + vector(GF(2), [1]*3 + [0]*(len(t)-3))
    print(tt)

    i = 0
    for a, b in zip(tt, t):
      if a != b:
        print('i', i)
      i += 1

    # m = self.nearest_codeword_zemor(tt)
    m = self.nearest_codeword(tt)
    print('mmmm')
    print(m)
    print(t)
    print('----')
    print(self.is_codeword(m))
    print(m == t, sum(1 if a != b else 0 for (a, b) in zip(m, t)))
    # print(self.is_codeword(t), sum(1 if a != b else 0 for (a, b) in zip(tt, t)))

  def encode(self, w):
    return vector(GF(2), w) * self.Gen

  def is_codeword(self, w):
    for v in self.G.vertices():
      Ev = self.G.edges_incident(v, labels = False)
      x_indices = [self.edge_map[e] for e in Ev]
      x = [w[ind] for ind in x_indices]
      if not self.S.is_codeword(x): return False
    return True

  def nearest_codeword_zemor(self, w):
    # Uses Zemor's algorithm from On Expander Codes
    todos = [self.A, self.B] # left and right todos

    if len(self.edge_map) != len(w):
      raise "Wrong length message!"

    while len(todos[0]) != 0 or len(todos[1]) != 0:
      # lens = len(todos[0]), len(todos[1])
      next_todos = [set(), set()]
      for i in [0, 1]:
        for v in todos[i]:
          Ev = self.G.edges_incident(v, labels = False)
          x_indices = [self.edge_map[e] for e in Ev]
          x = [w[ind] for ind in x_indices]
          if self.S.is_codeword(x): continue
          y = self.S.nearest_codeword(x)
          for (ind, b) in zip(x_indices, y):
            w[ind] = b

          for e in Ev:
            # print(e, v, 1-i)
            next_todos[1-i].add(e[0] if e[0] != v else e[1])
          # print(i, todos[1-i])
      # print(w)
      todos = next_todos
      # print(todos)
      # exit()
      # if len(todos[0]) >= lens[0] or len(todos[1]) >= lens[1]:
      #   raise "Fail: error sizes are not decreasing"
    return w

  def nearest_codeword(self, w):
    w = w[:]
    to_check = self.G.edges(labels = False)

    not_done = True
    while not_done:
      to_flip = set()
      for e in self.G.edges(labels = False):
        count = 0
        for v in e:
          Ev = self.G.edges_incident(v, labels = False)
          x_indices = [self.edge_map[e_] for e_ in Ev]
          x = [w[ind] for ind in x_indices]
          if not self.S.is_codeword(x):
            print(e, x_indices)
            count += 1
        if count == 2: to_flip.add(e)
      print(len(to_flip))
      if len(to_flip) == 0:
        not_done = False
      for e in to_flip:
        print(e, self.edge_map[e])
        old = w[self.edge_map[e]]
        w[self.edge_map[e]] += 1
    return w


  def nearest_codeword_old(self, w):
    to_check = self.G.edges(labels = False)
    while len(to_check) > 0:
      to_flip = set()
      for e in to_check:
        count = 0
        for v in e:
          Ev = self.G.edges_incident(v, labels = False)
          x_indices = [self.edge_map[e] for e in Ev]
          x = [w[ind] for ind in x_indices]
          if not self.S.is_codeword(x):
            count += 1
        if count == 2: to_flip.add(e)
      to_check = set()
      print(to_flip)
      for e in to_flip:
        print(self.edge_map[e])
        # in the c = 2 case, "more unsatisfied constraints" is equilavent to "only".
        for v in e:
          for o in self.G.edges_incident(v, labels = False):
            to_check.add(o)
        w[self.edge_map[e]] += 1 # flip, in GF(2)
      print('c', to_check)
    return w





# a random 128-vertex 5-regular graph with lamdba = 3.906354638221518:
BG0 = loads('x\x9cU\xd6e@\\W\x1a\xc6\xf1\xb8\x10ww\x83\x08qw\x1c\x1e \t\xc9\xc4\xc9\x04\x99\x00\x81\x00s\x06\xe2$\xed\xb6\xbb\xddl\xbd\xeb\xae\x95uw\xdfv\xa5]w\xad\xacT\xd6\xdd\xa5\xfd?\xf7t?\xf4K~\x0f\x99\xe1\xde#\xef{\x0e\xd7\rh\xca5\xb4d\n[BCwk.\x92W\x9e\xfc\x9b\xed_p}v@_v`~jx\xfa\\\xa6\xad\xa5\xb5\'\xd3\x9c\x1dt-5(\xdd\xdd\x95\xcb\x0e\xaeM\x8dHw4\xf4d\xce\xa7\xbb\xba{r\xd9!\xb5\xa9a\xe9\xc6\x86\xa6\xf6Lgsv\xe8s\x9e\xda\xd8\x90{6\xff\xff\x0b\xb9\xbc\xde\xce\xee\xb6\xa6\xf6\x8eL\xfa9\xff\x9f\x97\x1d\x96\x7f\xad>;<_\xfd\xd4_\x034P\x834XC4T\xc34\\y\x1a\xa1\x91\x1a\xa5\xd1\x1a\xa3\xb1\x1a\xa7\xf1\x9a\xa0\x89\x9a\xa4\xc9\x9a\xa2\xa9\x9a\xa6\xe9\x9a\xa1\x99\x9a\xa5\xd9\x9a\xa3\xb9\x9a\xa7\xf9Z\xa0\x85Z\xa4\xc5Z\xa2|\x15h\xa9\x96i\xb9V\xa8P+\xb5J\xab\xb5Fk\xb5N\xeb\xb5A\x1b\xb5I\x9b\xb5E[\xb5M\xdb\xb5C;\xb5K\xbbU\xa4b\x95\xa8Te*W\x85*U%\xa9Z5\xaa\xd5\x1e\xed\xd5>\xd5i\xbf\x0e(\xa5\x83:\xa4\xc3:\xa2\xa3:\xa6\xe3\xaa\xd7\t\xa5uR\rjT\x93\x9a\x95\xd1)\xb5\xa8Um:\xadvu\xe8\x8c:\xd5\xa5ne\x15\x94S\x8fzuV\xe7t^\x17tQ\x97tY}\xba\xa2\xab\x99\xfal\x9e\x17![{Sv\x046\xe0H,\xc1Q\x98\x8f\xa3q\x19\x8ea\xa9\xe6\xe2X,\xc2q^:\x1c\x8f\x93q\x02\x8e\xc4\x89,\xa8\x9f3\t\'\xe0d,\xc7)\xd8\x82SY\xeeq8\r\xf7\xe1t\x0c8\x03\x9bq&\xa6q\x16\x9b\xb2\x17gc\x13\xce\xc1E8\x17\x97\xe0<\xdc\x86\xf3\xd9\xban\\\x80\x0bq!\xfa\xf3E8\n\x17\xa3\x9f\xb7\x84\r\xf6{\xf3\xd1\xf3+\xc0\x0c.\xf5\xc6\xe32\xdc\x8e\xcb)\x83\xd5\xb8\x02\'b!^\xc4\x95x\x15WQ$\xe3q5\x9e\xc258\r\xd7b\x1e\xae\xc3-\xb8\x9eR\x1a\x8b\x1b\xb0\x117\xe2z\xdc\x84\x9bq3\n\xb7Pp\x0bp+\xfa\xf3mx\x14\xb7\xbb\x10q\x07\xe58\twb+\xeeB\xff\xfen\xbc\x84E\x14k\x0e\x8b\xd1\xdf+\xc1)X\x8a\xe7\xb1\x8cR\xf6\xfb\xcb\xf14V`;Vb\'VQ\xe8\xde\x7fa\x0fV\xe3R\xac\xc1\x15X\x8b\x85\xb8\x87v\xf0~\xedE\xcf\x7f\x1f\x1e\xc4:\xac\xc2\xfd\xd8\x85\x07h\x1a?\'\x85~\xceA<\x86\x87p\x07\x1e\xa6\xa5N\xe2\x11\x9c\x89G\xd1\xcf?F\xa3y\x1d\x8e\xe3Z\xac\xc7\x0bx\x82\xf6s\x1d\xa6\xd1\xf39\x89G\xb0\x01]\x97\x8d4\xa7\xeb\xa7\t\xfd\xdef,\xc3\x0c\x9e\xc0S\xb4n=\xb6\xe0\x15l\xc5\x9d\xd8FC\xcf\xc7\xd3\xe8\xfdk\xc7j\xec\xc0><C\xbb\xbb\xce;q#v\xa1\xe7\xd9\x8d\xae\x87,\x87\xc1!\x0c\xd8\x869\xf4|{\xd0\xe3\xeaE\xbf\xef,G\xc6Y<\x87\xae\xff\xf3X\x89\x178H\xdc\'\x17\xd1\x9f_B\x7f~\x19\xbd\xcf}\xe8\xfd\xb9\xc2q\xe3>\xb8\x8a\xae\xb7\xeb\xd0\xdf\xbb\x1e=\x8e\xe7\xa1\xfb\xe0\x06\x0e\xa5ux\xa3\x0f\'|>\xfa\xfd/@\xcf\xf7&\x8e,\xf7\xef\x0b\xd1\xcf\xb9\x86\xfe\xfcE\xe8\xfe\xb8\x99\x03\xcd}t\x0b\xee\xc6[q\r\xde\x86\xee\xbf\xdb\xd1\xfbx\x07\xc7\xde\x06\xbc\x13=\xff\xbb\xd0\xfd\xfdb\xdc\x8a/A?\xef\xa5>\x1c\xf1ex\x00_\x8e\xee\xb7Wpd\xa6\xf0\x95x\x19_\x85\xcb\xf1\xd5X\x8b\xaf\xe1@]\x85\xafE\xaf\xcf\xeb\xd0\xe3x=\xba\xbf\xdf\xc0q\xeb\xcf\xdf\x88\xee\x937\xa1\xd7\xe1\xcd\x1c\xc2\x1e\xf7[\xb0\x00\xefF\xcf\xfb\x1e\x8ef\xd7\xed\xbd\xe8>\xb9\x0f]\xb7o\xc5s\xf86\x0en?\xff\xed\xe8\x9f\xdf\x81\x9b\xf0\x9dX\x83\xefB\x8f\xeb\xdd\x1c\xef\xae\xb3\xf7\xa0\xeb\xf3\xbd\xd8\x8b\xef\xe3\xd0\xf7\xfc\xde\x8f\xee\xfb\x0f\xa0\xf7\xed\x83\\\x05\xa5\xf8!\xf4\xf7>\x8cg\xf0#\xe8\xfa\xfa(\x17\x85\x7f\xefc\xe8\xbe\xf88\xd7\x86\xeb\xf6\x13\xe8\xf1}\x92K\xc4}\xfb)\xf4\xba}\xda\x97\n~\x06]\xd7\x9f\xe5\x8a\xf1|?\x87>\x07\xeeG\xcf\xf7\x01.\x1e\x9f\x0f\x9fG\x8f\xe7\x0b\xe8\xba\xfe"\xd7\x91\xeb\xe8K\xe8\xf3\xefA\xf4{\x1eB\xd7\xd3\x97\xd1\xcf\xf9\n\x97V1~\x15\xbd\xae_C\xef\xd3\xd7\xb9\xca\\_\xdf\xc0\xc3\xf8Mt\x1d\x7f\x0b=\xafos\xd1\xed\xc2\xef\xa0\xeb\xf1\xbb\\{\x1e\xff\xf7\xd0\xfd\xf1}\xdc\x83?\xe02\xac\xc3\x1f\xa2\xfb\xfbG\xe8s\xe9\xc7\\\x91>\x87~\x82\xfe\xfd\x87\xd1\xf3|\x84\x8b\xd3\xe3~\x14\xfd\xbe\xc7\xd0\xef\xfb)\xfay?\xe3Zu\x9d\xfc\x1c]\x87\xbf@\xf7\xcf\xe3\xe8\xf3\xfa\t.\xdd\xfd\xf8$\xba\xcf\x9eB\xef\xf3/\xd1\xf3\xf8\x15W\xb2\xf7\xe1\xd7\xe8\xfb\xe77\\\xd0\xfe\xfeo\xd1\xe3\xfa\x1d\xd7\xb5\xc7\xfb{\xf4y\xf0\x07\xf4z\xfe\x11\xfd\xfe?q\x99{|\x7f\xe6Jw}\xfc\x05\xdd\x17\x7fE\x7f\xefo\xe8\xfa\xf9;\x17\xbe\x9f\xf3\x0ft?\xfd\x13}\x0e\xff\x8b?\x03|n\xfe\x9b?\x06<\xae\xff\xa0\xfb\xec\xbf\xe8u\xff\x1f\xba^\x9e\xe6O\x05\xf6%\xf4\xeb\xdf\xaf\x1f\x91\xad\n\xfd\x1d\x8b\\]a@\x8c\x14\\\x18\xe8X\xec\xb5\r\x83b\xe4\xd8\n\x83cd\xe5\xc2\x10\xc7\x127C\x18\x1a#\xef\r\xc3\x1cK=\x850<\xc6\nb^\x8c\x14t\x18\xe1X\xe6\xde\r#c\xe4\xfa\n\xa3bd\x06a\xb4cy\xf2\xb611v\x10\xc7:V\xf8h\t\xe3bd\xf6a|\x8c\x1e\xfa\x84\x18\xa9\x910\xd1\xb1\xd2\xdb\x12&\xc5\xc8\n\x87\xc9\x8eU.\x8e0\xc5Q\xc9\xd0\xa7\xc6\xc8\xd6\x85i1r\xca\x87\xe9\x8e\xd5^\xe80\xc3\xb1\xc6{\x1ef\xc6\xc8\xb5\x11f\xc5\xe8u\x98\x1d\xa3\x7fm\x8ecm2\xb2\xb91\x1e\'\xces\xdc\x93\xac\xe4|\xc7}.\x90\xb0 F\xcfm\xa1c\x9d\xaf\xa5\xb0\xc8q\xbfO\xa4\xb08F\x7faI\x8c\xd4a\xc8wL\xf9\xea\x0b\x051R\xddai\x8c^\xbee\x8e\x07\x93A.w<\xe4c:\xac\x88\xd1\xb3(t<\x9c\xac\xc3\xca\x18\xfd\x84U\x8eG\x92\x17\xaf\x8e\x91\xea\tk\x1c\x8f\xbap\xc2Z\xc7c>\xeb\xc3:\xc7\xe3\xc9\xf2\xad\x8f\x91\n\x0f\x1bb\xf4x7\xc6\xe8%\xd9\xe4X\xef\xa3\'lvL\'_\xd8\xe2x\xd2\x17m\xd8\x1a\xa3\'\xbf-FOs\xbbc\xa3;0\xecplNv~g\x8c\x9e\xd0.\xc7\x8cK?\xecvlM\xbeP\xe4\xd8\x96<\xac8F\x7f\xa1\xc4\xf1t\xb2:\xa5\x8e\xed\xee\x88P\xe6\xd8\x99\x8c\xa1\xdc\xb17i\x86\n\xc7\x0b\xc9\x8c+\x1d/\'\xc3\xa9"f\xfa\x82 ?5\xb8\xa3\xab\xab;\x17\xaa\xf9\xe1Z*\xefLoGO[\xa6\xb9%\x93\x0b5\xfe\x9f\xde\x9e\xbaPK\xe8m,|\x06\x13\xa7\x07\x17')
# its double cover, a 256-vertex 5-regular bipartite graph with lambda = 3.906354638221518:
G0 = BipartiteGraph(BG0.adjacency_matrix())

# or: a 16-vertex 3-regular graph with lambda = 2.471387453316782
BG = loads('x\x9cU\xcf\xc9n\x830\x10\x06\xe0&a5$t\xdf\xf7M\xf4\x92\xd7\xe8a$\x0e\x958F\x08\x12\x8b\xa0\xd0\xc0\xd4\xa0\xf6\x12\xa9=U\xbcu\x7f\xa7\xed!\x17\x7fx\xf0\x8c\x7f\x7f\xf6\xa7*\xcd\xe58\x7fK\xeb\xb9\xfaE<\xafW\xee=}q\x7f\xc5\x830v\x93wY\xe4\xf3F\xce\xd8\xe8b#\xa9+\xc5f\x14{I\x996\xf2#\xa9\xeaF\xb1\x15\xc5N\x92\xa5\xd3\x85\\\xce\xd8\xde\x98\x9a\xa5\xea\xef\xfb\xff\x80\x12\xed\xb2.\xa6\x8bR&\x1bu\xc1N\xd8M\xd8\ri\x8bz\xd4\xa7\x01\x19d\x92E69\xe4\x92 \x8f|\x1a\xd2\x88\x029a\xb1>\x14}\xb3\x07\r\xe8\xc3\x00\x0e\xd1j\xc2\x11\x140\xc0 \x0bnC\x1b\xee\xc0!\xdc\xd5\xe3\xe1\x1et\xe0>\xf4\xe0\x01.\xd5\xff\x0fq\xb5\xae\x1f\xc1\x11<F\x10\x17\x9e@\x1f\x9e\xeaX\xf0\x0c\xea\xbesD\xd4\xf5\x0b\xa8\xfb/\x11X\xf7]A\x9d\xeb\x1a\xf1\xf5\xfe\x06\x8f\xd0\xfb[\xb9\xe2\xbb06\xcb\xaa\xaa\x15\xdfw\xb1xm\xcb\xa6\x90\xb3\\*~\xe8\xda\xe6\x85\x1f\xdbl\xfc\x03\xa6+y\xc9')
G = BipartiteGraph(BG.adjacency_matrix())

# 64-vertex 7-regular graph with lambda = 4.424558369334110
BG7 = loads('x\x9cU\xd5\xe5C\x9bW\x14\xc7\xf1\x95B\x81PZ(\xee\x0e\xc1\x82\xbb\xcd\xbb\xedll\xeb\x969\xcb\x02<\x0b\x8c\x14\xf24\xc9\xda\tk;\xeb2wwwwwwww\xfb\x1b\xf6\xfdu\xdb\x8b\xbe\xe1\x03<\xd7\xce\xb9\xf7\x9e\xbb)i*\x1a\x0c9\xbe\xd0\xba`d&\xfa/\x9e\xd5[\x7f\xbaK\x1a7\xbbI\x8b\xeeR\xaf?=\xb0\xde\x99\r\xcd\xc4\x9ci79\xe1O\x0eD\x16\xa2n\xca\xb8?#\x10\x0e\xc6\x9c\r\x81\x85H,\xea.\x1b\xf7\xa7\x05&\x83Ss\xce\xfc\xb4\x9b\xba\xcd\xa8\x93\xc1\xe8\x7f\xbf\xff\xdf \xea\x89\xcfGf\xa7\xe6\xc2N`\x9b\xff{\xdc4ob\xc2M\xf7\xdav\xb6\xc4\x92l\xa9%[\x8a-\xb3TK\xb3t\xf3X\x86-\xb7L[a+-\xcb\xb2m\x95\xe5X\xae\xe5Y\xbe\x15X\xa1\x15Y\xb1\x95X\xa9\x95Y\xb9UX\xa5UY\xb5\xd5X\xad\xd5Y\xbd5\x98\xd7\x1a\xad\xc9\x9a\xad\xc5Z\xcdgm\xd6n\x1d\xd6i]\xd6m=\xd6k}\xd6o\x036hC6l#6jc\xce\x84\xeb\xd9\xba\x88\xf1-n\x06v\xe0r\xac\xc1L\x1c\xc4\x15X\x8c+\xb1\x14\xb3\xb0\x0c\xb3Yz6\xaeB\xf5\xcb\xc1d\xcc\xc5n\xcc\xc3t\xccG\x8dS@\xa0\x9dX\x88)X\x84\rX\x8c}X\x82#X\x8a\xe5X\x86mXNz\xda\xb1\x02s\xb0\x12\xd5\xbf\n\xd5\xbf\x1a\x87\xb0\x063\xb1\x16\xd5\xaf\x8e\xa4\xd6b=\xd6c\x03\xa6\xa2\x17\xfb\xb1\x11[\xb1\t\xd5\xaf\x99-\xd0<-X\x85\xad\xa8v>l\xc46\xac\xc0v6J\xed:P\xed:Q\xeb\xeaB\xcd\xd7\x8dy\xd8\xa3\r\xc5^\xf4b\x1f\xdb\xab~\xfd\xa8~\x03X\x87\x83\xd8\x8bC8\x8c\xc3\x1c\x82J\x1cA\xe5q\x14\x15\xe7\x18j\x1d\xdbc3\xee\x80j\xbf#\x8e\xe2N\x1c\x1d\x8d\xbb3j?vA\xe5uWT\xbf\xd5\xa8~\xbb\xa1\xf2\xbb;\x07-\x0b\xf7@\xad\xdbP\xf3\xec\x89\x05\xb8\x97\x0e"\x8ec\t\xee\x8d\xda\xf7}8\x9e\x8ao_T\xde\xd7\xa0\xf2\xb8\x1f\xea\xfb\xfe\xe8C?\x8e\xe1\x01\x1cf\xe5\xe7@T<\x07\xa1\xe2>\x18\x07\xf0\x10\xd4\xb9:\x14\xd5\xff0T\xbf\t\xae\x80\xda\x1d\x8e\x9a/\x80Mx\x04*\xee *\xeeI.\x8a\xe2\x98B\x9d\xdbi\xccE\x075\xdf\x91\xa8\xfd\x0f\xa1\xf6s\x06\xb5\xeeY\xae\x97\xda\x1f\x85j?\x87=\x18F\xcd\xb3\x16\xd5n\x1e\xb5\xbe\x05T\xde"\\\xca|tQ\xf9]\x87E\x18E\xf5\x8b\xa1\xceq\x9c\xab[\x88G\xa3\xbe\xafG\xe5\x7f\x03j\xdccPy;\x16\x15\xefq\\t\xed\xfb\xf1X\x8d\x8b\xba\xf8x\x02*\x8e\x8d\xa8unB\x8d\xbb\x19\x95\x87\x13)\x0f\x8a\xe3$\xd4x\'\xa3\xce\xe9)\x14\x8d.<\x15\x95\xe7-\xd8\x82\xa7\xa1\xbe\'()\xba\x8f\xa7\xa3\xce\xdf\x19\xa8u\x9d\x89\x8a\xf3,\n\x8e\xce\xd3\xd9\xa8q\xceA\xed\xc7\xb9\xa8|\x9e\x87\x8a\xeb|T\xdc\x17P\x9e\xb4\xee\x0bQy\xb9\x08\x95\xef\x8bQ\xf5\xe3\x12\xd4~]\x8a\x9a\xff2\x8a\x99\xe2\xbd\x1c5\xfe\x15\xa8{r%*\x7fW\xa1\xee\xf1\xd5\x94<\x9d\xdfkP\xf3\\\x8b:\x8f\xd7\xa1\xc6\xbb\x9e\x82\xa8qn@\xc5s#*\x1f7\xa1\xf2q3*\x9e[(\x9bZ\xf7\xad*\x9fx\x1b*\x1f\xb7\xa3\xf2x\x07j\xbc;)\xae\x1a\xe7.\xd48w\xa3\xd6{\x0f%W\xf1\xdd\x8b\x8a\xeb>\xd4~\xdeO!\xd6\xb9y\x00u\x7f\x1e\xa4,\xeb\xef\x87P\xe3?L\x91V\xbfGP\xe3>\x8a\xda\x8f\xc7(\xdd\xca\xf7\xe3\xa8\xfb\xf2\x04\x85\\\xf7\xf0IT\x9cO\xa1\xfa?My\xd7\xf9x\x86"\xaf\xf1\x9fE\xcd\xfb\x1c*\xbe\xe7)\xfd\xba\xef/\xa0\xf2\xf7"*\x7f/\xf1 \xa8\xdd\xcb\xa8\xbf_A\x8d\xf3*\xcf\x84\xe6\x7f\x8d\xc7B\xeb|\x1d\x15\xff\x1b\xa8|\xbf\x89j\xf7\x16O\x89\xce\xdd\xdb\xa8\xfa\xfd\x0ej\x9d\xef\xf2\xc0h\xbf\xde\xe3\x99\xd1>\xbf\xcfc\xa3\xf3\xf3\x01\xaa\xdd\x87\xa8\xf9>\xe2\t\xd2\xba>\xe6!\xd2\xf7OPy\xfb\x145\xffg\xa8|\x7f\xce3\xa5\xf1\xbe@\xb5\xfb\x12\xb5\x9e\xafx\xbc\x94\xaf\xafQ\xdf\xbfA\x8d\xff-O\x9a\xfa\x7f\x87\x9a\xe7{\x1e8\xf5\xfb\x81gN\xdf\x7f\xe4\xb1\xd3\xb8?\xf1\xe4i}?\xa3\xda\xff\x82\x8a\xebW=\x84\xf8\x1b\x8f\xa1\xda\xff\xee,\xba\x7fx\xfd)\xe1\x85\x85H\xd4\xfd3\xe1\xf7\xac\x8d\x87c\xb3\xcet\xc8\x89\xba\x7f%\xe2\xb15\xee\xdf\xf1I\xdf?\xb4W\xa5+')
G7 = BipartiteGraph(BG7.adjacency_matrix())
# Expander(G7, Hadamard(3))

# 16-vertex 7-regular graph with lambda = 3.3
BG7_16 = loads('x\x9cU\xd1\xc9O\xdb@\x18\xc6\xe1\x12\xb2:[YJ[\xe8\xcajh\x9b\xd2\x8d\xa5\x1b\xb4Pz\x18)\x07$\x1f\x91\xe5$\xa3\x10\x11\x88\x07;*\x17\xa4\xf6T\xe5\xbf\xe6\xf7\xd2r\xe0\x92\'\x1e\xbf\xdf7\xe3\xf9~g\xdaI\xd4\xb5\x8d\xeey\x14\x1f\'\xff\xf0~^\xff\xba\xb1\xd5?.s\xe9\xc6\xfd\xa0\x14\xfe\xb2\xbd\xeeqj;.;\n\xb2a<H\\\xae\x19\x94\xc3~\x94\xda\x8bp\x10\xa7\x89\xcb7\x83b\xd8\x8a\xda\'\xf6\xac\xe3\n\xb7\xba\xb6\xa2\xe4\xff\xff\x9b@\xe2\r\xcf\xe2^\xfb\xa4o\xc3[\xeb\x9e+\xfa\xa3#W\xf2\xcd\x1d3f2f\xdcdM\xce\xe4M\xc1\x14M\xc9x\xa6l*\xa6jj\xa6n\x8f\x9cw\x1dj\xfeue\xcc`\x05\xb3X\xc5<\xd6\xd0\xc3:V\xf1.\xd6q\x82\xd69\x9c\xc4\x12N\xa1r\xd3X\xc1{X\xc3\x19T\xfe\xbe\x0e\x82\x0fP\xfd\x1f\xa2\xfa\xcfb\x11\xe7P}\x1e\xa1\xea\x1e\xeb\xd8\xf8\x04\xb5\xcfS,\xe03T\xfe9*?\x8f\xca/\xf0\x91z\xbf\x88Z_B\x9dg\x19\xb5\xff\nW\xa0\xf7>j}\x15\xcb\xb8\x86:\xef\x0b\xd4\xf7\xbd\xe4\xa2T\xff\n\x95k\xa0\xd6_\xa3\xf6YG\xf5{\xa3\xeb\xc4\xb7\xa8\xfc;T\xbf\xf7\xa8~\x1f\xb8l=o\xa0\xea7Q\xf5[\xa8\xfamF\xa1\xdcG\x06"?\xa1r\x9f5\x1e\xfc\x82z\xfe\x8a\xaa\xdbA\xd5\xedjx\xf8M\x03\xc4\xef\xf6\xd2\xed\xf9A\xae?\x18\xc4\x89\xdb\x1f\x05\xde\xe9\xb0\x9f\xf6l\xa7k\x13\xf7c4L\x0f\xdd\xc1\xb0\xd5\xb8\x02\xc0\x8c\xbd\xf9')
G7_16 = BipartiteGraph(BG7_16.adjacency_matrix())

x = Expander(BG0, ParityCode(5))
# w = x.nearest_codeword([1]*5*128)

# x = Expander(G, ParityCode(3))
# w = x.nearest_codeword([1]*3*16)
exit()

print(w)
print(x.is_codeword(w))
# print(x.is_codeword([0]*3*16))



